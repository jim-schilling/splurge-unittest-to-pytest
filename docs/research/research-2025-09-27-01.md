# Two-pass metadata-based replacement (2025-09-27)

Summary
-------
This note documents the two-pass, metadata-driven replacement mechanism added to the
transformer pipeline to safely perform shape-changing conversions (for example, converting
an expression-level Call node into a statement-level Assert node).

Why
---
LibCST visitors separate expression-level and statement-level nodes. Previously some
transforms attempted to return statement nodes directly from expression-level leave methods
which is fragile and can produce invalid trees. The two-pass approach records replacements
during a first pass (when PositionProvider metadata is available) and applies them on a
second pass so we never return incompatible node shapes in a single traversal.

Design
------
- ReplacementRegistry: records planned replacements keyed by source-position tuples
  (start_line, start_col, end_line, end_col) derived from PositionProvider metadata.
- ReplacementApplier: a second-pass CST transformer that depends on PositionProvider
  and substitutes expression-level replacements (in leave_Call) and statement-level
  replacements (in leave_SimpleStatementLine) based on recorded positions.
- Usage: transformers schedule a replacement by calling `record_replacement(old_node, new_node)`
  where `old_node` is the original node (the one we want to replace) and `new_node` is the
  replacement CST node (expression or statement). The main transformer runs with
  `MetadataWrapper(module).visit(transformer)` for the first pass and runs
  `MetadataWrapper(transformed_cst).visit(ReplacementApplier(registry))` for the second pass
  when the registry contains recorded replacements.

Files
-----
- `splurge_unittest_to_pytest/transformers/transformer_helper.py`
  - ReplacementRegistry and ReplacementApplier implementations.
- `splurge_unittest_to_pytest/transformers/unittest_transformer.py`
  - `UnittestToPytestCSTTransformer.record_replacement()` and two-pass invocation
    in `transform_code`; `leave_Call` now records statement replacements instead of
    returning statement nodes directly.
- `splurge_unittest_to_pytest/transformers/assert_transformer.py`
  - Assertion helper functions return `cst.Assert` for many unittest -> pytest
    assertion conversions (these are recorded by `leave_Call` during pass 1).
- `tests/integration/test_two_pass_transform.py`
  - End-to-end tests verifying the two-pass transformation produces statement-level
    replacements in final generated code.

Notes for contributors
----------------------
- When writing a transformer helper that must change node shape (expression -> statement),
  return a CST node of the target shape from the helper and ensure the caller calls
  `record_replacement(old_node, new_node)` instead of returning the new_node directly from
  an expression-level leave method.
- The registry matching relies on PositionProvider metadata; do not attempt to record
  replacements before wrapping the module with `MetadataWrapper`.

Test coverage
-------------
Focused unit tests for assertion transformations and subtest conversion exist under
`tests/unit/` and an end-to-end two-pass test is in `tests/integration/test_two_pass_transform.py`.

Follow-ups
----------
- Migrate any remaining ad-hoc places that attempt to return statement nodes from
  expression-level leave methods to use `record_replacement()` and the registry.
- Consider expanding ReplacementApplier to handle more complex contexts if needed.

Generated: 2025-09-27
