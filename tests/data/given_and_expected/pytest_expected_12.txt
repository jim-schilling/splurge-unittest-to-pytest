import contextlib
import sqlite3
from unittest.mock import Mock, PropertyMock, patch

import pytest

@pytest.fixture(scope="module", autouse=True)
def setup_module():
    global test_db_path
    test_db_path = ":memory:"
    init_test_database()
    yield
    test_db_path = None

def init_test_database():
    with sqlite3.connect(test_db_path) as conn:
        conn.execute(
            '''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT UNIQUE,
                email TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        '''
        )
        conn.execute(
            '''
            CREATE TABLE IF NOT EXISTS posts (
                id INTEGER PRIMARY KEY,
                user_id INTEGER,
                title TEXT,
                content TEXT,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        '''
        )

class TestDatabaseManager:
    @pytest.fixture(scope="class", autouse=True)
    def setup_class(self):
        self.db_manager = DatabaseManager(test_db_path)
        self.user_repository = UserRepository(self.db_manager)
        self.post_repository = PostRepository(self.db_manager)
        yield
        self.db_manager.close()
        self.db_manager = None
        self.user_repository = None
        self.post_repository = None

    @pytest.fixture(autouse=True)
    def setup_method(self):
        self.test_user_data = {"username": "testuser", "email": "test@example.com"}
        self.test_post_data = {"title": "Test Post", "content": "This is a test post content"}
        self.cleanup_data()
        yield
        self.cleanup_data()
        self.test_user_data = None
        self.test_post_data = None

    def cleanup_data(self):
        with self.db_manager.get_connection() as conn:
            conn.execute("DELETE FROM posts")
            conn.execute("DELETE FROM users")
            conn.commit()

    def test_user_creation_and_retrieval(self):
        user_id = self.user_repository.create_user(
            self.test_user_data["username"], self.test_user_data["email"]
        )
        assert user_id is not None

        user = self.user_repository.get_user_by_id(user_id)
        assert user["username"] == self.test_user_data["username"]
        assert user["email"] == self.test_user_data["email"]

    def test_user_duplicate_username_constraint(self):
        self.user_repository.create_user(
            self.test_user_data["username"], self.test_user_data["email"]
        )

        with pytest.raises(sqlite3.IntegrityError):
            self.user_repository.create_user(
                self.test_user_data["username"], "different@example.com"
            )

    def test_post_creation_with_foreign_key(self):
        user_id = self.user_repository.create_user(
            self.test_user_data["username"], self.test_user_data["email"]
        )

        post_id = self.post_repository.create_post(
            user_id, self.test_post_data["title"], self.test_post_data["content"]
        )
        assert post_id is not None

        post = self.post_repository.get_post_by_id(post_id)
        assert post["user_id"] == user_id
        assert post["title"] == self.test_post_data["title"]

    @patch.object(DatabaseManager, 'get_connection')
    def test_database_connection_error_handling(self, mock_get_connection):
        mock_get_connection.side_effect = sqlite3.Error("Database connection failed")

        with pytest.raises(sqlite3.Error):
            self.user_repository.create_user(
                self.test_user_data["username"], self.test_user_data["email"]
            )

    def test_transaction_rollback_on_error(self):
        user_id = self.user_repository.create_user(
            self.test_user_data["username"], self.test_user_data["email"]
        )

        # Simulate transaction that should rollback
        try:
            with self.db_manager.get_connection() as conn:
                conn.execute("UPDATE users SET username = ? WHERE id = ?", ("newusername", user_id))
                # Force an error to trigger rollback
                conn.execute("INVALID SQL STATEMENT")
        except sqlite3.Error:
            pass

        # Verify original data is preserved due to rollback
        user = self.user_repository.get_user_by_id(user_id)
        assert user["username"] == self.test_user_data["username"]

class DatabaseManager:
    def __init__(self, db_path):
        self.db_path = db_path
        self._connection = None

    @contextlib.contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

    def close(self):
        if self._connection:
            self._connection.close()

class UserRepository:
    def __init__(self, db_manager):
        self.db = db_manager

    def create_user(self, username, email):
        with self.db.get_connection() as conn:
            cursor = conn.execute(
                "INSERT INTO users (username, email) VALUES (?, ?)", (username, email)
            )
            conn.commit()
            return cursor.lastrowid

    def get_user_by_id(self, user_id):
        with self.db.get_connection() as conn:
            cursor = conn.execute("SELECT * FROM users WHERE id = ?", (user_id,))
            row = cursor.fetchone()
            return dict(row) if row else None

class PostRepository:
    def __init__(self, db_manager):
        self.db = db_manager

    def create_post(self, user_id, title, content):
        with self.db.get_connection() as conn:
            cursor = conn.execute(
                "INSERT INTO posts (user_id, title, content) VALUES (?, ?, ?)",
                (user_id, title, content),
            )
            conn.commit()
            return cursor.lastrowid

    def get_post_by_id(self, post_id):
        with self.db.get_connection() as conn:
            cursor = conn.execute("SELECT * FROM posts WHERE id = ?", (post_id,))
            row = cursor.fetchone()
            return dict(row) if row else None
