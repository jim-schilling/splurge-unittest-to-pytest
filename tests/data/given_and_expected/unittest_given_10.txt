import unittest
from unittest.mock import Mock, patch, MagicMock
import json


def setUpModule():
    global api_config, mock_logger
    api_config = {
        "base_url": "https://api.test.com",
        "timeout": 30,
        "retries": 3
    }
    mock_logger = MagicMock()


def tearDownModule():
    global api_config, mock_logger
    api_config = None
    mock_logger = None


class TestAPIClient(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.api_client = APIClient(api_config)
        cls.api_client.set_logger(mock_logger)
        cls.mock_session = Mock()
        cls.api_client.session = cls.mock_session
    
    @classmethod
    def tearDownClass(cls):
        cls.api_client = None
        cls.mock_session = None
    
    def setUp(self):
        self.test_endpoint = "/users"
        self.test_data = {"name": "John", "email": "john@test.com"}
        self.mock_response = Mock()
        self.mock_response.status_code = 200
        self.mock_response.json.return_value = {"id": 1, **self.test_data}
        self.mock_session.reset_mock()
    
    def tearDown(self):
        self.test_endpoint = None
        self.test_data = None
        self.mock_response = None
    
    def test_successful_get_request(self):
        self.mock_session.get.return_value = self.mock_response
        result = self.api_client.get(self.test_endpoint)
        
        self.assertIsNotNone(result)
        self.assertEqual(result["id"], 1)
        self.mock_session.get.assert_called_once_with(
            f"{api_config['base_url']}{self.test_endpoint}",
            timeout=api_config['timeout']
        )
    
    def test_successful_post_request(self):
        self.mock_response.status_code = 201
        self.mock_session.post.return_value = self.mock_response
        result = self.api_client.post(self.test_endpoint, self.test_data)
        
        self.assertIsNotNone(result)
        self.assertEqual(result["name"], "John")
        self.mock_session.post.assert_called_once()
    
    @patch('time.sleep')
    def test_retry_mechanism(self, mock_sleep):
        self.mock_response.status_code = 500
        self.mock_session.get.return_value = self.mock_response
        
        result = self.api_client.get(self.test_endpoint)
        self.assertIsNone(result)
        self.assertEqual(self.mock_session.get.call_count, 3)
        mock_sleep.assert_called()
    
    def test_request_timeout_handling(self):
        from requests.exceptions import Timeout
        self.mock_session.get.side_effect = Timeout("Request timeout")
        
        result = self.api_client.get(self.test_endpoint)
        self.assertIsNone(result)
        mock_logger.error.assert_called_with("Request timeout for /users")


class TestDataProcessor(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.processor = DataProcessor()
        cls.validator = DataValidator()
    
    @classmethod
    def tearDownClass(cls):
        cls.processor = None
        cls.validator = None
    
    def setUp(self):
        self.sample_data = [
            {"id": 1, "name": "Alice", "age": 25, "active": True},
            {"id": 2, "name": "Bob", "age": 30, "active": False},
            {"id": 3, "name": "Charlie", "age": 35, "active": True}
        ]
        self.invalid_data = [
            {"id": "invalid", "name": "", "age": -5}
        ]
    
    def tearDown(self):
        self.sample_data = None
        self.invalid_data = None
    
    def test_filter_active_users(self):
        active_users = self.processor.filter_active(self.sample_data)
        self.assertEqual(len(active_users), 2)
        self.assertTrue(all(user["active"] for user in active_users))
    
    def test_calculate_average_age(self):
        avg_age = self.processor.calculate_average_age(self.sample_data)
        self.assertEqual(avg_age, 30)
    
    def test_data_validation_success(self):
        is_valid = self.validator.validate_user_data(self.sample_data[0])
        self.assertTrue(is_valid)
    
    def test_data_validation_failure(self):
        is_valid = self.validator.validate_user_data(self.invalid_data[0])
        self.assertFalse(is_valid)


class APIClient:
    def __init__(self, config):
        self.config = config
        self.session = None
        self.logger = None
    
    def set_logger(self, logger):
        self.logger = logger
    
    def get(self, endpoint):
        url = f"{self.config['base_url']}{endpoint}"
        for attempt in range(self.config['retries']):
            try:
                response = self.session.get(url, timeout=self.config['timeout'])
                if response.status_code == 200:
                    return response.json()
                elif response.status_code >= 500:
                    if attempt < self.config['retries'] - 1:
                        import time
                        time.sleep(1)
                        continue
            except Exception as e:
                if self.logger:
                    self.logger.error(f"Request timeout for {endpoint}")
                return None
        return None
    
    def post(self, endpoint, data):
        url = f"{self.config['base_url']}{endpoint}"
        response = self.session.post(url, json=data, timeout=self.config['timeout'])
        if response.status_code in [200, 201]:
            return response.json()
        return None


class DataProcessor:
    def filter_active(self, users):
        return [user for user in users if user.get("active", False)]
    
    def calculate_average_age(self, users):
        if not users:
            return 0
        total_age = sum(user["age"] for user in users)
        return total_age / len(users)


class DataValidator:
    def validate_user_data(self, user):
        if not isinstance(user.get("id"), int):
            return False
        if not user.get("name", "").strip():
            return False
        if user.get("age", 0) < 0:
            return False
        return True
