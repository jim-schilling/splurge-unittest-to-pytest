"""Complex pytest example with parametrize fixtures for data transformation pipeline."""
from dataclasses import dataclass
from decimal import Decimal
from typing import Any, Callable

import pytest


@dataclass
class TransformationStep:
    """Represents a data transformation step."""
    name: str
    transform: Callable[[Any], Any]
    validator: Callable[[Any], bool] | None = None


class DataPipeline:
    """Data transformation pipeline."""
    
    def __init__(self) -> None:
        self.steps: list[TransformationStep] = []
        self.execution_log: list[dict[str, Any]] = []
    
    def add_step(
        self,
        name: str,
        transform: Callable[[Any], Any],
        validator: Callable[[Any], bool] | None = None
    ) -> None:
        """Add a transformation step to the pipeline."""
        self.steps.append(TransformationStep(name, transform, validator))
    
    def execute(self, data: Any) -> Any:
        """Execute the pipeline on input data."""
        self.execution_log.clear()
        current_data = data
        
        for step in self.steps:
            try:
                # Validate input if validator exists
                if step.validator and not step.validator(current_data):
                    raise ValueError(f"Validation failed for step: {step.name}")
                
                # Execute transformation
                result = step.transform(current_data)
                
                # Log execution
                self.execution_log.append({
                    "step": step.name,
                    "status": "success",
                    "input": current_data,
                    "output": result
                })
                
                current_data = result
            except Exception as e:
                self.execution_log.append({
                    "step": step.name,
                    "status": "error",
                    "error": str(e),
                    "input": current_data
                })
                raise
        
        return current_data
    
    def get_step_output(self, step_name: str) -> Any:
        """Get the output of a specific step from the last execution."""
        for log_entry in self.execution_log:
            if log_entry["step"] == step_name and log_entry["status"] == "success":
                return log_entry["output"]
        return None


class TestDataPipelineTransformations:
    """Test data pipeline with various transformation scenarios using pytest parametrize."""
    
    @pytest.fixture(autouse=True)
    def setup(self) -> None:
        """Set up test pipeline."""
        self.pipeline = DataPipeline()
    
    @pytest.mark.parametrize(
        "name,input_val,transform,expected_type,expected_value,validator",
        [
            (
                "Integer to Float",
                42,
                lambda x: float(x),
                float,
                42.0,
                lambda x: isinstance(x, int)
            ),
            (
                "Float to Decimal",
                3.14159,
                lambda x: Decimal(str(x)),
                Decimal,
                None,
                lambda x: isinstance(x, float)
            ),
            (
                "String to Integer",
                "12345",
                lambda x: int(x),
                int,
                12345,
                lambda x: isinstance(x, str) and x.isdigit()
            ),
            (
                "Negative Float Rounding",
                -7.8,
                lambda x: round(x),
                int,
                -8,
                lambda x: isinstance(x, (int, float))
            ),
            (
                "Scientific Notation Conversion",
                "1.5e3",
                lambda x: float(x),
                float,
                1500.0,
                lambda x: isinstance(x, str)
            ),
        ],
        ids=["int_to_float", "float_to_decimal", "str_to_int", "negative_round", "scientific"]
    )
    def test_numeric_transformations_with_different_types(
        self,
        name: str,
        input_val: Any,
        transform: Callable[[Any], Any],
        expected_type: type,
        expected_value: Any,
        validator: Callable[[Any], bool]
    ) -> None:
        """Test numeric transformations with various input types."""
        self.pipeline.add_step(name, transform, validator)
        
        result = self.pipeline.execute(input_val)
        
        assert isinstance(result, expected_type)
        if expected_value is not None:
            assert result == expected_value
        
        # Verify execution log
        assert len(self.pipeline.execution_log) == 1
        assert self.pipeline.execution_log[0]["status"] == "success"
    
    @pytest.mark.parametrize(
        "config",
        [
            pytest.param(
                {
                    "name": "Uppercase and Strip Pipeline",
                    "input": "  hello world  ",
                    "steps": [
                        ("strip", str.strip),
                        ("uppercase", str.upper),
                    ],
                    "expected_output": "HELLO WORLD",
                    "intermediate_results": {
                        "strip": "hello world",
                        "uppercase": "HELLO WORLD"
                    }
                },
                id="uppercase_strip"
            ),
            pytest.param(
                {
                    "name": "Replace and Title Case Pipeline",
                    "input": "python_is_awesome",
                    "steps": [
                        ("replace_underscores", lambda x: x.replace("_", " ")),
                        ("title_case", str.title),
                    ],
                    "expected_output": "Python Is Awesome",
                    "intermediate_results": {
                        "replace_underscores": "python is awesome",
                        "title_case": "Python Is Awesome"
                    }
                },
                id="replace_title"
            ),
            pytest.param(
                {
                    "name": "Complex Text Normalization",
                    "input": "  DATA-processing_SYSTEM  ",
                    "steps": [
                        ("strip", str.strip),
                        ("lowercase", str.lower),
                        ("replace_dash", lambda x: x.replace("-", " ")),
                        ("replace_underscore", lambda x: x.replace("_", " ")),
                        ("title", str.title),
                    ],
                    "expected_output": "Data Processing System",
                    "intermediate_results": {
                        "strip": "DATA-processing_SYSTEM",
                        "lowercase": "data-processing_system",
                        "replace_dash": "data processing_system",
                        "replace_underscore": "data processing system",
                        "title": "Data Processing System"
                    }
                },
                id="complex_normalization"
            ),
        ]
    )
    def test_chained_string_transformations(
        self,
        config: dict[str, Any]
    ) -> None:
        """Test chained string transformation pipelines."""
        for step_name, transform_func in config["steps"]:
            self.pipeline.add_step(step_name, transform_func)
        
        result = self.pipeline.execute(config["input"])
        
        # Verify final output
        assert result == config["expected_output"]
        
        # Verify intermediate results
        for step_name, expected_output in config["intermediate_results"].items():
            actual_output = self.pipeline.get_step_output(step_name)
            assert actual_output == expected_output, \
                f"Intermediate result mismatch at step: {step_name}"
        
        # Verify all steps executed successfully
        assert len(self.pipeline.execution_log) == len(config["steps"])
        for log_entry in self.pipeline.execution_log:
            assert log_entry["status"] == "success"
    
    @pytest.mark.parametrize(
        "scenario",
        [
            pytest.param(
                {
                    "name": "List Filtering and Mapping",
                    "input": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                    "steps": [
                        ("filter_even", lambda x: [i for i in x if i % 2 == 0]),
                        ("square", lambda x: [i ** 2 for i in x]),
                        ("sum", sum),
                    ],
                    "expected_output": 220,  # (2^2 + 4^2 + 6^2 + 8^2 + 10^2)
                    "step_outputs": {
                        "filter_even": [2, 4, 6, 8, 10],
                        "square": [4, 16, 36, 64, 100],
                        "sum": 220
                    }
                },
                id="list_filter_map"
            ),
            pytest.param(
                {
                    "name": "Dictionary Key Transformation",
                    "input": {"first_name": "John", "last_name": "Doe", "age_years": 30},
                    "steps": [
                        ("snake_to_camel", lambda d: {
                            "".join(word.capitalize() for word in k.split("_")): v
                            for k, v in d.items()
                        }),
                        ("add_full_name", lambda d: {
                            **d,
                            "FullName": f"{d.get('FirstName', '')} {d.get('LastName', '')}"
                        }),
                    ],
                    "expected_keys": {"FirstName", "LastName", "AgeYears", "FullName"},
                    "expected_full_name": "John Doe"
                },
                id="dict_transform"
            ),
            pytest.param(
                {
                    "name": "Nested List Flattening and Processing",
                    "input": [[1, 2], [3, 4], [5, 6]],
                    "steps": [
                        ("flatten", lambda x: [item for sublist in x for item in sublist]),
                        ("multiply_by_2", lambda x: [i * 2 for i in x]),
                        ("filter_gt_5", lambda x: [i for i in x if i > 5]),
                    ],
                    "expected_output": [6, 8, 10, 12],
                    "step_outputs": {
                        "flatten": [1, 2, 3, 4, 5, 6],
                        "multiply_by_2": [2, 4, 6, 8, 10, 12],
                        "filter_gt_5": [6, 8, 10, 12]
                    }
                },
                id="nested_list"
            ),
        ]
    )
    def test_data_structure_transformations(
        self,
        scenario: dict[str, Any]
    ) -> None:
        """Test transformations on complex data structures."""
        for step_name, transform_func in scenario["steps"]:
            self.pipeline.add_step(step_name, transform_func)
        
        result = self.pipeline.execute(scenario["input"])
        
        # Verify final output
        if "expected_output" in scenario:
            assert result == scenario["expected_output"]
        
        if "expected_keys" in scenario:
            assert set(result.keys()) == scenario["expected_keys"]
        
        if "expected_full_name" in scenario:
            assert result["FullName"] == scenario["expected_full_name"]
        
        # Verify step outputs if provided
        if "step_outputs" in scenario:
            for step_name, expected_output in scenario["step_outputs"].items():
                actual_output = self.pipeline.get_step_output(step_name)
                assert actual_output == expected_output
    
    @pytest.mark.parametrize(
        "name,input_val,steps,should_raise,expected_log_status",
        [
            (
                "Type Validation Failure",
                "not a number",
                [("validate_int", lambda x: int(x), lambda x: isinstance(x, int))],
                ValueError,
                "error"
            ),
            (
                "Division by Zero",
                10,
                [("divide_by_zero", lambda x: x / 0)],
                ZeroDivisionError,
                "error"
            ),
            (
                "Invalid Dictionary Key Access",
                {"name": "Test"},
                [("access_missing_key", lambda x: x["age"])],
                KeyError,
                "error"
            ),
        ],
        ids=["validation_fail", "division_zero", "key_error"]
    )
    def test_validation_and_error_handling(
        self,
        name: str,
        input_val: Any,
        steps: list[tuple],
        should_raise: type[Exception],
        expected_log_status: str
    ) -> None:
        """Test pipeline validation and error handling scenarios."""
        for step_config in steps:
            if len(step_config) == 3:
                step_name, transform_func, validator = step_config
                self.pipeline.add_step(step_name, transform_func, validator)
            else:
                step_name, transform_func = step_config
                self.pipeline.add_step(step_name, transform_func)
        
        with pytest.raises(should_raise):
            self.pipeline.execute(input_val)
        
        # Verify error was logged
        assert len(self.pipeline.execution_log) == 1
        assert self.pipeline.execution_log[0]["status"] == expected_log_status
        assert "error" in self.pipeline.execution_log[0]
