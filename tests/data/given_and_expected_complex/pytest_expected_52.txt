"""Complex pytest example with parametrize fixtures for API response validation."""
from dataclasses import dataclass
from enum import Enum
from typing import Any

import pytest


class HttpMethod(Enum):
    """HTTP methods."""
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"


class StatusCode(Enum):
    """HTTP status codes."""
    OK = 200
    CREATED = 201
    NO_CONTENT = 204
    BAD_REQUEST = 400
    UNAUTHORIZED = 401
    FORBIDDEN = 403
    NOT_FOUND = 404
    INTERNAL_ERROR = 500


@dataclass
class ApiResponse:
    """Mock API response."""
    status_code: int
    headers: dict[str, str]
    body: dict[str, Any] | None
    
    @property
    def is_success(self) -> bool:
        """Check if response is successful."""
        return 200 <= self.status_code < 300


class ApiClient:
    """Mock API client."""
    
    def __init__(self) -> None:
        self._resources: dict[str, dict[str, Any]] = {}
        self._next_id: int = 1
    
    def request(
        self,
        method: HttpMethod,
        endpoint: str,
        data: dict[str, Any] | None = None
    ) -> ApiResponse:
        """Make API request."""
        if method == HttpMethod.GET:
            return self._handle_get(endpoint)
        elif method == HttpMethod.POST:
            return self._handle_post(endpoint, data)
        elif method == HttpMethod.PUT:
            return self._handle_put(endpoint, data)
        elif method == HttpMethod.DELETE:
            return self._handle_delete(endpoint)
        elif method == HttpMethod.PATCH:
            return self._handle_patch(endpoint, data)
        
        return ApiResponse(
            status_code=StatusCode.BAD_REQUEST.value,
            headers={"Content-Type": "application/json"},
            body={"error": "Invalid method"}
        )
    
    def _handle_get(self, endpoint: str) -> ApiResponse:
        """Handle GET request."""
        if endpoint.startswith("/resources/"):
            resource_id = endpoint.split("/")[-1]
            if resource_id in self._resources:
                return ApiResponse(
                    status_code=StatusCode.OK.value,
                    headers={"Content-Type": "application/json"},
                    body=self._resources[resource_id]
                )
            return ApiResponse(
                status_code=StatusCode.NOT_FOUND.value,
                headers={"Content-Type": "application/json"},
                body={"error": "Resource not found"}
            )
        
        return ApiResponse(
            status_code=StatusCode.OK.value,
            headers={"Content-Type": "application/json"},
            body={"resources": list(self._resources.values())}
        )
    
    def _handle_post(self, endpoint: str, data: dict[str, Any] | None) -> ApiResponse:
        """Handle POST request."""
        if not data:
            return ApiResponse(
                status_code=StatusCode.BAD_REQUEST.value,
                headers={"Content-Type": "application/json"},
                body={"error": "Missing data"}
            )
        
        resource_id = str(self._next_id)
        self._next_id += 1
        resource = {"id": resource_id, **data}
        self._resources[resource_id] = resource
        
        return ApiResponse(
            status_code=StatusCode.CREATED.value,
            headers={"Content-Type": "application/json", "Location": f"/resources/{resource_id}"},
            body=resource
        )
    
    def _handle_put(self, endpoint: str, data: dict[str, Any] | None) -> ApiResponse:
        """Handle PUT request."""
        resource_id = endpoint.split("/")[-1]
        if resource_id not in self._resources:
            return ApiResponse(
                status_code=StatusCode.NOT_FOUND.value,
                headers={"Content-Type": "application/json"},
                body={"error": "Resource not found"}
            )
        
        self._resources[resource_id] = {"id": resource_id, **(data or {})}
        return ApiResponse(
            status_code=StatusCode.OK.value,
            headers={"Content-Type": "application/json"},
            body=self._resources[resource_id]
        )
    
    def _handle_patch(self, endpoint: str, data: dict[str, Any] | None) -> ApiResponse:
        """Handle PATCH request."""
        resource_id = endpoint.split("/")[-1]
        if resource_id not in self._resources:
            return ApiResponse(
                status_code=StatusCode.NOT_FOUND.value,
                headers={"Content-Type": "application/json"},
                body={"error": "Resource not found"}
            )
        
        self._resources[resource_id].update(data or {})
        return ApiResponse(
            status_code=StatusCode.OK.value,
            headers={"Content-Type": "application/json"},
            body=self._resources[resource_id]
        )
    
    def _handle_delete(self, endpoint: str) -> ApiResponse:
        """Handle DELETE request."""
        resource_id = endpoint.split("/")[-1]
        if resource_id not in self._resources:
            return ApiResponse(
                status_code=StatusCode.NOT_FOUND.value,
                headers={"Content-Type": "application/json"},
                body={"error": "Resource not found"}
            )
        
        del self._resources[resource_id]
        return ApiResponse(
            status_code=StatusCode.NO_CONTENT.value,
            headers={},
            body=None
        )


class TestApiClientEndpoints:
    """Test API client with various endpoint scenarios using pytest parametrize."""
    
    @pytest.fixture(autouse=True)
    def setup(self) -> None:
        """Set up test API client."""
        self.client = ApiClient()
    
    @pytest.mark.parametrize(
        "method,endpoint,data,expected_status,expected_body_keys,expected_body_contains,description",
        [
            (
                HttpMethod.POST,
                "/resources",
                {"name": "Test Resource", "value": 100},
                StatusCode.CREATED.value,
                ["id", "name", "value"],
                None,
                "Create resource with POST"
            ),
            (
                HttpMethod.GET,
                "/resources/1",
                None,
                StatusCode.OK.value,
                ["id", "name", "value"],
                None,
                "Read created resource with GET"
            ),
            (
                HttpMethod.PATCH,
                "/resources/1",
                {"value": 200},
                StatusCode.OK.value,
                None,
                {"value": 200},
                "Partially update resource with PATCH"
            ),
            (
                HttpMethod.PUT,
                "/resources/1",
                {"name": "Updated Resource", "value": 300},
                StatusCode.OK.value,
                None,
                {"name": "Updated Resource", "value": 300},
                "Fully update resource with PUT"
            ),
            (
                HttpMethod.DELETE,
                "/resources/1",
                None,
                StatusCode.NO_CONTENT.value,
                None,
                None,
                "Delete resource with DELETE"
            ),
            (
                HttpMethod.GET,
                "/resources/1",
                None,
                StatusCode.NOT_FOUND.value,
                None,
                None,
                "Verify resource deleted with GET"
            ),
        ],
        ids=["step_0_create", "step_1_read", "step_2_patch", "step_3_put", "step_4_delete", "step_5_verify"]
    )
    def test_http_methods_on_same_resource(
        self,
        method: HttpMethod,
        endpoint: str,
        data: dict[str, Any] | None,
        expected_status: int,
        expected_body_keys: list[str] | None,
        expected_body_contains: dict[str, Any] | None,
        description: str
    ) -> None:
        """Test different HTTP methods on the same resource lifecycle."""
        response = self.client.request(method, endpoint, data)
        
        assert response.status_code == expected_status
        
        if expected_body_keys is not None:
            assert response.body is not None
            for key in expected_body_keys:
                assert key in response.body
        
        if expected_body_contains is not None:
            assert response.body is not None
            for key, value in expected_body_contains.items():
                assert response.body[key] == value
    
    @pytest.mark.parametrize(
        "method,endpoint,data,expected_status,should_have_error,description",
        [
            (
                HttpMethod.GET,
                "/resources/999",
                None,
                StatusCode.NOT_FOUND.value,
                True,
                "GET non-existent resource"
            ),
            (
                HttpMethod.POST,
                "/resources",
                None,
                StatusCode.BAD_REQUEST.value,
                True,
                "POST without data"
            ),
            (
                HttpMethod.PUT,
                "/resources/999",
                {"name": "Test"},
                StatusCode.NOT_FOUND.value,
                True,
                "PUT to non-existent resource"
            ),
            (
                HttpMethod.PATCH,
                "/resources/999",
                {"name": "Test"},
                StatusCode.NOT_FOUND.value,
                True,
                "PATCH non-existent resource"
            ),
            (
                HttpMethod.DELETE,
                "/resources/999",
                None,
                StatusCode.NOT_FOUND.value,
                True,
                "DELETE non-existent resource"
            ),
        ],
        ids=["get_missing", "post_no_data", "put_missing", "patch_missing", "delete_missing"]
    )
    def test_error_conditions_and_edge_cases(
        self,
        method: HttpMethod,
        endpoint: str,
        data: dict[str, Any] | None,
        expected_status: int,
        should_have_error: bool,
        description: str
    ) -> None:
        """Test various error conditions and edge cases."""
        # Create a resource for context (though it won't be accessed in these tests)
        self.client.request(HttpMethod.POST, "/resources", {"name": "Existing Resource"})
        
        response = self.client.request(method, endpoint, data)
        
        assert response.status_code == expected_status
        assert not response.is_success
        
        if should_have_error:
            assert response.body is not None
            assert "error" in response.body
    
    @pytest.mark.parametrize(
        "operation,resources,updates,delete_ids,remaining_ids,verify_count,description",
        [
            (
                "create_multiple",
                [
                    {"name": "Resource A", "priority": 1},
                    {"name": "Resource B", "priority": 2},
                    {"name": "Resource C", "priority": 3},
                ],
                None,
                None,
                None,
                3,
                "Create three resources"
            ),
            (
                "update_all",
                None,
                [
                    ("1", {"status": "active"}),
                    ("2", {"status": "pending"}),
                    ("3", {"status": "inactive"}),
                ],
                None,
                None,
                None,
                "Update all resources with different statuses"
            ),
            (
                "delete_selective",
                None,
                None,
                ["2"],
                ["1", "3"],
                None,
                "Delete middle resource, verify others remain"
            ),
        ],
        ids=["create_three", "update_statuses", "delete_middle"]
    )
    def test_bulk_operations_with_multiple_resources(
        self,
        operation: str,
        resources: list[dict[str, Any]] | None,
        updates: list[tuple[str, dict[str, Any]]] | None,
        delete_ids: list[str] | None,
        remaining_ids: list[str] | None,
        verify_count: int | None,
        description: str
    ) -> None:
        """Test creating and managing multiple resources."""
        if operation == "create_multiple":
            created_ids = []
            for resource_data in resources:
                response = self.client.request(HttpMethod.POST, "/resources", resource_data)
                assert response.status_code == StatusCode.CREATED.value
                assert response.body is not None
                created_ids.append(response.body["id"])
            
            # Verify count via GET all
            list_response = self.client.request(HttpMethod.GET, "/resources")
            assert list_response.status_code == StatusCode.OK.value
            assert len(list_response.body["resources"]) == verify_count
        
        elif operation == "update_all":
            # Create resources first
            for i in range(3):
                self.client.request(
                    HttpMethod.POST,
                    "/resources",
                    {"name": f"Resource {i+1}"}
                )
            
            for resource_id, update_data in updates:
                response = self.client.request(
                    HttpMethod.PATCH,
                    f"/resources/{resource_id}",
                    update_data
                )
                assert response.status_code == StatusCode.OK.value
                assert response.body is not None
                assert response.body["status"] == update_data["status"]
        
        elif operation == "delete_selective":
            # Create resources first
            for i in range(3):
                self.client.request(
                    HttpMethod.POST,
                    "/resources",
                    {"name": f"Resource {i+1}"}
                )
            
            for resource_id in delete_ids:
                response = self.client.request(HttpMethod.DELETE, f"/resources/{resource_id}")
                assert response.status_code == StatusCode.NO_CONTENT.value
            
            # Verify remaining resources exist
            for resource_id in remaining_ids:
                response = self.client.request(HttpMethod.GET, f"/resources/{resource_id}")
                assert response.status_code == StatusCode.OK.value
