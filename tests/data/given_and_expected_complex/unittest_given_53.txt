"""Complex unittest example with subTest for data transformation pipeline."""
import unittest
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import Any, Callable


@dataclass
class TransformationStep:
    """Represents a data transformation step."""
    name: str
    transform: Callable[[Any], Any]
    validator: Callable[[Any], bool] | None = None


class DataPipeline:
    """Data transformation pipeline."""
    
    def __init__(self) -> None:
        self.steps: list[TransformationStep] = []
        self.execution_log: list[dict[str, Any]] = []
    
    def add_step(
        self,
        name: str,
        transform: Callable[[Any], Any],
        validator: Callable[[Any], bool] | None = None
    ) -> None:
        """Add a transformation step to the pipeline."""
        self.steps.append(TransformationStep(name, transform, validator))
    
    def execute(self, data: Any) -> Any:
        """Execute the pipeline on input data."""
        self.execution_log.clear()
        current_data = data
        
        for step in self.steps:
            try:
                # Validate input if validator exists
                if step.validator and not step.validator(current_data):
                    raise ValueError(f"Validation failed for step: {step.name}")
                
                # Execute transformation
                result = step.transform(current_data)
                
                # Log execution
                self.execution_log.append({
                    "step": step.name,
                    "status": "success",
                    "input": current_data,
                    "output": result
                })
                
                current_data = result
            except Exception as e:
                self.execution_log.append({
                    "step": step.name,
                    "status": "error",
                    "error": str(e),
                    "input": current_data
                })
                raise
        
        return current_data
    
    def get_step_output(self, step_name: str) -> Any:
        """Get the output of a specific step from the last execution."""
        for log_entry in self.execution_log:
            if log_entry["step"] == step_name and log_entry["status"] == "success":
                return log_entry["output"]
        return None


class TestDataPipelineTransformations(unittest.TestCase):
    """Test data pipeline with various transformation scenarios using subTest."""
    
    def setUp(self) -> None:
        """Set up test pipeline."""
        self.pipeline = DataPipeline()
    
    def test_numeric_transformations_with_different_types(self) -> None:
        """Test numeric transformations with various input types."""
        transformations = [
            {
                "name": "Integer to Float",
                "input": 42,
                "transform": lambda x: float(x),
                "expected_type": float,
                "expected_value": 42.0,
                "validator": lambda x: isinstance(x, int)
            },
            {
                "name": "Float to Decimal",
                "input": 3.14159,
                "transform": lambda x: Decimal(str(x)),
                "expected_type": Decimal,
                "validator": lambda x: isinstance(x, float)
            },
            {
                "name": "String to Integer",
                "input": "12345",
                "transform": lambda x: int(x),
                "expected_type": int,
                "expected_value": 12345,
                "validator": lambda x: isinstance(x, str) and x.isdigit()
            },
            {
                "name": "Negative Float Rounding",
                "input": -7.8,
                "transform": lambda x: round(x),
                "expected_type": int,
                "expected_value": -8,
                "validator": lambda x: isinstance(x, (int, float))
            },
            {
                "name": "Scientific Notation Conversion",
                "input": "1.5e3",
                "transform": lambda x: float(x),
                "expected_type": float,
                "expected_value": 1500.0,
                "validator": lambda x: isinstance(x, str)
            },
        ]
        
        for trans in transformations:
            with self.subTest(transformation=trans["name"]):
                self.pipeline = DataPipeline()
                self.pipeline.add_step(
                    trans["name"],
                    trans["transform"],
                    trans.get("validator")
                )
                
                result = self.pipeline.execute(trans["input"])
                
                self.assertIsInstance(result, trans["expected_type"])
                if "expected_value" in trans:
                    self.assertEqual(result, trans["expected_value"])
                
                # Verify execution log
                self.assertEqual(len(self.pipeline.execution_log), 1)
                self.assertEqual(self.pipeline.execution_log[0]["status"], "success")
    
    def test_chained_string_transformations(self) -> None:
        """Test chained string transformation pipelines."""
        pipeline_configs = [
            {
                "name": "Uppercase and Strip Pipeline",
                "input": "  hello world  ",
                "steps": [
                    ("strip", str.strip),
                    ("uppercase", str.upper),
                ],
                "expected_output": "HELLO WORLD",
                "intermediate_results": {
                    "strip": "hello world",
                    "uppercase": "HELLO WORLD"
                }
            },
            {
                "name": "Replace and Title Case Pipeline",
                "input": "python_is_awesome",
                "steps": [
                    ("replace_underscores", lambda x: x.replace("_", " ")),
                    ("title_case", str.title),
                ],
                "expected_output": "Python Is Awesome",
                "intermediate_results": {
                    "replace_underscores": "python is awesome",
                    "title_case": "Python Is Awesome"
                }
            },
            {
                "name": "Complex Text Normalization",
                "input": "  DATA-processing_SYSTEM  ",
                "steps": [
                    ("strip", str.strip),
                    ("lowercase", str.lower),
                    ("replace_dash", lambda x: x.replace("-", " ")),
                    ("replace_underscore", lambda x: x.replace("_", " ")),
                    ("title", str.title),
                ],
                "expected_output": "Data Processing System",
                "intermediate_results": {
                    "strip": "DATA-processing_SYSTEM",
                    "lowercase": "data-processing_system",
                    "replace_dash": "data processing_system",
                    "replace_underscore": "data processing system",
                    "title": "Data Processing System"
                }
            },
        ]
        
        for config in pipeline_configs:
            with self.subTest(pipeline=config["name"]):
                self.pipeline = DataPipeline()
                
                for step_name, transform_func in config["steps"]:
                    self.pipeline.add_step(step_name, transform_func)
                
                result = self.pipeline.execute(config["input"])
                
                # Verify final output
                self.assertEqual(result, config["expected_output"])
                
                # Verify intermediate results
                for step_name, expected_output in config["intermediate_results"].items():
                    actual_output = self.pipeline.get_step_output(step_name)
                    self.assertEqual(
                        actual_output,
                        expected_output,
                        f"Intermediate result mismatch at step: {step_name}"
                    )
                
                # Verify all steps executed successfully
                self.assertEqual(len(self.pipeline.execution_log), len(config["steps"]))
                for log_entry in self.pipeline.execution_log:
                    self.assertEqual(log_entry["status"], "success")
    
    def test_data_structure_transformations(self) -> None:
        """Test transformations on complex data structures."""
        transformation_scenarios = [
            {
                "name": "List Filtering and Mapping",
                "input": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                "steps": [
                    ("filter_even", lambda x: [i for i in x if i % 2 == 0]),
                    ("square", lambda x: [i ** 2 for i in x]),
                    ("sum", sum),
                ],
                "expected_output": 220,  # (2^2 + 4^2 + 6^2 + 8^2 + 10^2)
                "step_outputs": {
                    "filter_even": [2, 4, 6, 8, 10],
                    "square": [4, 16, 36, 64, 100],
                    "sum": 220
                }
            },
            {
                "name": "Dictionary Key Transformation",
                "input": {"first_name": "John", "last_name": "Doe", "age_years": 30},
                "steps": [
                    ("snake_to_camel", lambda d: {
                        "".join(word.capitalize() for word in k.split("_")): v
                        for k, v in d.items()
                    }),
                    ("add_full_name", lambda d: {
                        **d,
                        "FullName": f"{d.get('FirstName', '')} {d.get('LastName', '')}"
                    }),
                ],
                "expected_keys": {"FirstName", "LastName", "AgeYears", "FullName"},
                "expected_full_name": "John Doe"
            },
            {
                "name": "Nested List Flattening and Processing",
                "input": [[1, 2], [3, 4], [5, 6]],
                "steps": [
                    ("flatten", lambda x: [item for sublist in x for item in sublist]),
                    ("multiply_by_2", lambda x: [i * 2 for i in x]),
                    ("filter_gt_5", lambda x: [i for i in x if i > 5]),
                ],
                "expected_output": [6, 8, 10, 12],
                "step_outputs": {
                    "flatten": [1, 2, 3, 4, 5, 6],
                    "multiply_by_2": [2, 4, 6, 8, 10, 12],
                    "filter_gt_5": [6, 8, 10, 12]
                }
            },
        ]
        
        for scenario in transformation_scenarios:
            with self.subTest(scenario=scenario["name"]):
                self.pipeline = DataPipeline()
                
                for step_name, transform_func in scenario["steps"]:
                    self.pipeline.add_step(step_name, transform_func)
                
                result = self.pipeline.execute(scenario["input"])
                
                # Verify final output
                if "expected_output" in scenario:
                    self.assertEqual(result, scenario["expected_output"])
                
                if "expected_keys" in scenario:
                    self.assertEqual(set(result.keys()), scenario["expected_keys"])
                
                if "expected_full_name" in scenario:
                    self.assertEqual(result["FullName"], scenario["expected_full_name"])
                
                # Verify step outputs if provided
                if "step_outputs" in scenario:
                    for step_name, expected_output in scenario["step_outputs"].items():
                        actual_output = self.pipeline.get_step_output(step_name)
                        self.assertEqual(actual_output, expected_output)
    
    def test_validation_and_error_handling(self) -> None:
        """Test pipeline validation and error handling scenarios."""
        error_scenarios = [
            {
                "name": "Type Validation Failure",
                "input": "not a number",
                "steps": [
                    ("validate_int", lambda x: int(x), lambda x: isinstance(x, int)),
                ],
                "should_raise": ValueError,
                "expected_log_status": "error"
            },
            {
                "name": "Division by Zero",
                "input": 10,
                "steps": [
                    ("divide_by_zero", lambda x: x / 0),
                ],
                "should_raise": ZeroDivisionError,
                "expected_log_status": "error"
            },
            {
                "name": "Invalid Dictionary Key Access",
                "input": {"name": "Test"},
                "steps": [
                    ("access_missing_key", lambda x: x["age"]),
                ],
                "should_raise": KeyError,
                "expected_log_status": "error"
            },
        ]
        
        for scenario in error_scenarios:
            with self.subTest(scenario=scenario["name"]):
                self.pipeline = DataPipeline()
                
                for step_config in scenario["steps"]:
                    if len(step_config) == 3:
                        step_name, transform_func, validator = step_config
                        self.pipeline.add_step(step_name, transform_func, validator)
                    else:
                        step_name, transform_func = step_config
                        self.pipeline.add_step(step_name, transform_func)
                
                with self.assertRaises(scenario["should_raise"]):
                    self.pipeline.execute(scenario["input"])
                
                # Verify error was logged
                self.assertEqual(len(self.pipeline.execution_log), 1)
                self.assertEqual(
                    self.pipeline.execution_log[0]["status"],
                    scenario["expected_log_status"]
                )
                self.assertIn("error", self.pipeline.execution_log[0])


if __name__ == "__main__":
    unittest.main()
